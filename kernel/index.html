<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="./style.css">
<body>
  <div id="header">
    <label>Resolution</label><input type="text" id="resolution" maxlength="4" size="1" value="10" />
    <label>Sigma</label><input type="text" id="sigma" maxlength="4" size="1" value="1" />
    <button id="run" type="button" class="btn btn-primary">Run</button>
  </div>
  <div id="x"></div>
  <div id="y"></div>
  <div id="graph"></div>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script>

    //Set parameters
    var CHR_NUMBER = 16;
    var resolution = parseInt(document.querySelector("#resolution").value);
    var sigma = parseInt(document.querySelector("#sigma").value);
    var size = (screen.width - 200) / CHR_NUMBER;
    var coefficient = 1 / (sigma * Math.sqrt(2 * Math.PI));
    var constant = 2 * sigma * sigma;

    //Main
    for(var i = 1; i <= CHR_NUMBER; i++) {
      for(var j = 1; j <= CHR_NUMBER; j++) {
	block(i , j);
      }
    }

    d3.select("#run").on("click", function() {
      var resolution = parseInt(document.querySelector("#resolution").value);
      var sigma = parseInt(document.querySelector("#sigma").value);
    });

    //Draw the axis
    var x_axis = d3.select("#x").append("svg").append("g").attr("id", "x-axis").attr("transform", "translate(" + (screen.width - (CHR_NUMBER + 2) * size) * 0 + ", 22)");
    var y_axis = d3.select("#y").append("svg").append("g").attr("id", "y-axis");
    d3.select("#y").style("height", CHR_NUMBER * size + 100 + "px").style("margin-left", (-size * 0.125) + 1 + "px");
    var color = d3.scale.category20b();
    for(var i = 1; i <= CHR_NUMBER; i++) {
      x_axis.append("rect").attr("id", "x-" + i).attr("class", "x-axis-block")
      .attr("width", size).attr("height", size / 4)
      .attr("fill", color(i - 1)).attr("x", i * size).attr("y", 0);
      x_axis.append("text").attr("id", "x-text-" + i).attr("class", "x-text")
      .attr("x", size * (i + 0.5)).attr("y", -size / 8)
      .text(i).attr("text-anchor", "middle").attr("fill", "White");

      y_axis.append("rect").attr("id", "y-" + i).attr("class", "y-axis-block")
      .attr("width", size / 4).attr("height", size)
      .attr("fill", color(i - 1)).attr("x", size * 0.75).attr("y", (i - 0.75) * size);
      y_axis.append("text").attr("id", "y-text-" + i).attr("class", "y-text")
      .attr("y", size * (i - 0.125)).attr("x", size / 2)
      .text(i).attr("text-anchor", "end").attr("fill", "White");
    }

    var block = d3.select("#graph").append("g").attr("id", "block");

    //Read the data
    function block(source, target) {
      d3.json("data/cor/chr" + source + "-" + target + "_cor.json", function(cor) {

	//Create a heatmap matrix, which is a 2-dim array
	var heatmap = new Array(resolution);
	for(var i = 0; i < resolution; i++) {
	  heatmap[i] = new Array(resolution);
	}
	for(var i = 0; i < resolution; i++) {
	  for(var j = 0; j < resolution; j++) {
	    heatmap[i][j] = 0;
	  }
	}

	//Round the value by the resolution
	cor.forEach(function (e) {
	  var temp_s = Math.round(resolution * e[0]);
	  var temp_t = Math.round(resolution * e[1]);
	  temp_s = (temp_s == resolution) ? (temp_s - 1) : (temp_s);
	  temp_t = (temp_t == resolution) ? (temp_t - 1) : (temp_t);
	  heatmap[temp_s][temp_t] += 1;
	});
	cor = JSON.stringify(cor);

	//Recod the heatmap position which is the ppi coordinate
	var list = [];
	for(var i = 0; i < resolution; i++) {
	  for(var j = 0; j < resolution; j++) {
	    if(heatmap[i][j] != 0) {
	      list.push([i, j]);
	    }
	  }
	}

	//Calculate the heatmap values
	for(var i = 0; i < resolution; i++) {
	  for(var j = 0; j < resolution; j++) {
	    list.forEach(function(e) {
	      if(i != e[0] && j != e[1]) {
		heatmap[i][j] += gaussian(e[0], e[1], i, j, sigma);
	      }
	    });
	  }
	}

	//Draw the heatmap
	var max = 0;
	heatmap.forEach(function(e) {
	  if(d3.max(e) > max) {
	    max = d3.max(e);
	  }
	});
	var color = d3.scale.linear()
	  .domain([0, max/4, max/2, 3 * max/4, max])
	  .range(["#111", "#003e3e", "#e7d", "#e4e124", "#fff"]);

	block.append("canvas")
	  .attr("width", resolution)
	  .attr("height", resolution)
	  .style("width", size + "px")
	  .style("height", size + "px")
	  .style("margin-left", ((-size * 0.125 + 1) + size * source) + "px")
	  .style("margin-top", (72 + size * (target - 0.75)) + "px")
	  .call(drawImage);

	// Compute the pixel colors; scaled by CSS.
	function drawImage(canvas) {
	  var context = canvas.node().getContext("2d"),
	      image = context.createImageData(resolution, resolution);

	  for (var y = 0, p = -1; y < resolution; ++y) {
	    for (var x = 0; x < resolution; ++x) {
	      var c = d3.rgb(color(heatmap[y][x]));
	      image.data[++p] = c.r;
	      image.data[++p] = c.g;
	      image.data[++p] = c.b;
	      image.data[++p] = 255;
	    }
	  }
	  context.putImageData(image, 0, 0);
	}
      });
    }

    //Gaussian Distribution
    function gaussian(cx, cy, x, y) {
      var distance = Math.pow(x - cx, 2) + Math.pow(y - cy, 2);
      return coefficient * Math.exp(-distance / constant);
    }
  </script>
